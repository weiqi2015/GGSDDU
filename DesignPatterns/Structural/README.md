
## 外观模式
外观(Facade)模式 又叫作 门面模式，是 **迪米特法则** 的典型应用，
定义：为子系统中的一组接口提供一个一致(稳定)的界面，Façade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用(复用)。

使用场景： 
    1、为复杂的模块或子系统提供外界访问的模块。 
    2、子系统相对独立。 
    3、预防低水平人员带来的风险。

例子：
拍照：布景、灯光、构图、相机
外观模式 就是 专业摄影团队，他们全部都包办，你不需要直到布景、灯光这些，只需要找他们就行。

优点： 
    1 减少系统相互依赖； 
    2 提高灵活性；
    3 提高了安全性。

缺点：
    不符合开闭原则。

### 拓展
使用 抽象外观 解决 不符合开闭原则问题。

## 代理模式
定义：为其他对象提供一种代理以控制(隔离，使用接口)对这对象的访问。
访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。

例子：
代理服务器功能，不支持服务器直连，需要通过代理服务器连接真正的服务器；
代理服务器会做一些检测工作（扩展内容），通过后才能连接服务器。

优点：
1 客户端和目标对象分离，降低系统耦合度
2 高扩展性

缺点是：
1 增加代理对象，增加额外工作
2 会造成请求处理速度变慢；
3 增加系统的复杂度；

### 拓展-动态代理
AOP框架

## 适配器模式
定义：将一个类的接口转换成客户希望的另一个接口。
Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

例子：
项目迭代，需要提供新的接口，然后用适配器连接旧的接口，保留原来的代码不变。

优点： 
    - 可以让任何两个没有关联的类一起运行。 
    - 提高了类的复用。 
    - 加了类的透明度。 
    - 灵活性好。

缺点： 
    - 过多地使用适配器，会让系统非常零乱，不易整体进行把握。

## 装饰模式
定义：动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码 & 减少子类个数）。

例子：
有一个圆形的类，draw接口 画出圆形状；
装饰器给 圆形添加 红色的边框（新的功能），调用装饰器的 draw接口 得到红色的圆形。

优点：
    - 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。

缺点：
    - 多层装饰比较复杂。

## 桥接模式
定义：将抽象部分与实现部分分离，使它们都可以独立地变化。

优点： 
    - 抽象和实现的分离
    - 优秀的扩展能力
    - 实现细节对客户透明

缺点：
    - 桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。
  
## 组合模式
定义：将对象组合成树形结构以表示”部分-整体“的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性(稳定)。
优点： 
- 高层模块调用简单
- 节点自由增加。

缺点：
- 在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。

## 享元模式
定义：运用共享技术有效地支持大量细粒度的对象，解决性能问题。

围棋或者是五指棋由一个棋盘和黑白棋组成；
棋子的大小、形状是不变的，黑棋颜色永远是黑色，白棋颜色永远是白色；
在下棋的过程中，黑白棋外观不会变化，变化的只是棋子的位置。

非享元模式实现：
抽象 棋子接口，
实现 黑棋 为黑色，
实现 白棋 为白色，
在棋盘对应位置上面**创建** 黑棋 或者 白棋 对象。

享元模式实现：
抽象 棋子接口，    抽象享元角色
实现 黑棋 为黑色， 具体享元角色
实现 白棋 为白色， 具体享元角色
在棋盘对应位置上面**使用** 黑棋 或者 白棋 对象 绘制棋子。


## 模式之间的区别
### 装饰模式 和 桥接模式
装饰模式：实现接口         拓展功能可以叠加，是一个整体
桥接模式：组合方式使用接口  仅仅只是使用某个接口